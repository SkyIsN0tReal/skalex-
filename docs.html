<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Documentations</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
  <style>
    /* CSS Variables */
    :root {
      --accent: #F56E0F;
      --border: #2A2A2D;
      --muted: #878787;
      --bg: #151419;
      --sidebar: #1B1B1E;
      --text: #EDEDED;
      --text-secondary: #B0B0B0;
      --card-bg: #1E1E21;
      --code-bg: #2A2A2D;
      --sidebar-width: 260px;
    }

    /* Reset & Base Styles */
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: var(--bg);
      overscroll-behavior: none;
    }

    /* Upload View */
    #upload-view {
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 24px;
    }
    .upload-card {
      width: 100%;
      max-width: 640px;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      background: var(--card-bg);
    }
    .upload-title {
      margin: 0 0 8px 0;
      font-size: 24px;
    }
    .upload-sub {
      margin: 0 0 16px 0;
      color: var(--muted);
    }
    .row {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    input[type="file"] { flex: 1; }
    button {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--card-bg);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
    }
    button.primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    .error {
      margin-top: 10px;
      color: #b91c1c;
      min-height: 1.2em;
    }

    /* Docs View Layout */
    #docs-view { display: none; min-height: 100vh; }
    .layout { display: flex; min-height: 100vh; }

    /* Sidebar */
    aside {
      width: var(--sidebar-width);
      flex: 0 0 var(--sidebar-width);
      min-width: var(--sidebar-width);
      max-width: var(--sidebar-width);
      background: var(--sidebar);
      border-right: 1px solid var(--border);
      padding: 16px;
      display: flex;
      flex-direction: column;
      position: sticky;
      top: 0;
      height: 100vh;
      overflow: auto;
      overflow-x: hidden;
      overscroll-behavior: none;
    }
    aside.accent-border { border-right-color: var(--accent); }
    .sidebar-resizer { position: absolute; top: 0; right: 0; width: 8px; height: 100%; cursor: col-resize; }
    .brand {
      font-weight: 600;
      margin: 4px 8px 12px 8px;
    }
    .nav-item {
      border: 0;
      background: transparent;
      text-align: left;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      color: var(--text);
      margin-bottom: 4px;
      display: block;
      width: fit-content;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
    }
    .nav-item:hover { background: #2A2A2D; }
    .nav-item.active { background: transparent; color: var(--bg); }
    .nav-item::before { content: ""; position: absolute; inset: 0; background: var(--accent); border-radius: 8px; opacity: 0; transition: opacity 200ms ease; z-index: -1; }
    .nav-item.active::before { opacity: 1; }

    /* Main Content */
    main { flex: 1; padding: 24px; overscroll-behavior: none; }
    .page-title {
      margin: 0 0 8px 0;
      font-size: 28px;
    }
    .description {
      margin: 8px 0 12px 0;
      color: var(--text-secondary);
      white-space: pre-wrap;
      line-height: 1.6;
    }

    /* Tabs */
    .tabs {
      position: absolute;
      top: 6px;
      right: 8px;
      display: flex;
      gap: 8px;
      margin: 0;
      flex-wrap: wrap;
      z-index: 1;
    }
    .tab {
      padding: 8px 12px;
      border: 0;
      border-radius: 8px;
      background: var(--card-bg);
      cursor: pointer;
      color: var(--text);
    }
    .tab:hover { background: #2A2A2D; }
    .tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    .tab-select {
      padding: 6px 10px;
      border: 0;
      border-radius: 8px;
      background: var(--card-bg);
      cursor: pointer;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      line-height: 14px;
    }
    .tab-select svg { width: 14px; height: 14px; color: var(--text-secondary); }
    .tab-select .arrow { transition: transform 160ms ease; }
    .tab-select.open .arrow { transform: rotate(180deg); }
    .tab-menu {
      position: absolute;
      top: 32px;
      right: 0;
      display: block;
      visibility: hidden;
      opacity: 0;
      transform: translateY(-6px);
      min-width: 140px;
      border: 0;
      border-radius: 8px;
      background: var(--card-bg);
      padding: 6px;
      z-index: 2;
      transition: opacity 160ms ease, transform 160ms ease, visibility 160ms;
    }
    .tab-menu.open { visibility: visible; opacity: 1; transform: translateY(0); }
    .tab-menu .tab {
      width: 100%;
      text-align: left;
      margin: 0;
      display: block;
    }

    /* Code Blocks */
    .code-group { position: relative; }
    .code-cell {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .code-cell pre {
      background: var(--code-bg);
      border: 0;
      border-radius: 10px;
      margin: 0;
      padding: 8px;
    }
    .code-cell.with-tabs pre { padding: 14px 12px; }
    pre {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      overflow: auto;
      background: var(--code-bg);
    }
    pre code.hljs { display: block; padding: 0; }
    pre::-webkit-scrollbar,
    .code-cell::-webkit-scrollbar,
    body::-webkit-scrollbar,
    aside::-webkit-scrollbar,
    main::-webkit-scrollbar {
      width: 0;
      height: 0;
    }
    pre, .code-cell, body, aside, main { scrollbar-width: none; overscroll-behavior: none; }
    *::-webkit-scrollbar { width: 0; height: 0; }
    * { scrollbar-width: none; }
    .hljs { background: transparent; color: var(--text); }
    pre code { color: var(--text); }
    
    /* Custom Syntax Highlighting for Dark Theme */
    .hljs-keyword { color: #FF6B6B; }
    .hljs-string { color: #51CF66; }
    .hljs-number { color: #FFD43B; }
    .hljs-literal { color: #FFD43B; }
    .hljs-comment { color: #A1A1AA; }
    .hljs-function { color: #74C0FC; }
    .hljs-title { color: #74C0FC; }
    .hljs-params { color: #FFD43B; }
    .hljs-built_in { color: #FF922B; }
    .hljs-type { color: #F783AC; }
    .hljs-variable { color: #EDEDED; }
    .hljs-attr { color: #A5D8FF; }
    .hljs-property { color: #A5D8FF; }
    .hljs-selector-tag { color: #FF6B6B; }
    .hljs-selector-id { color: #74C0FC; }
    .hljs-selector-class { color: #74C0FC; }
    .hljs-tag { color: #FF6B6B; }
    .hljs-name { color: #FF6B6B; }
    .hljs-attribute { color: #A5D8FF; }
    .hljs-value { color: #51CF66; }
    .hljs-regexp { color: #FF922B; }
    .hljs-symbol { color: #FFD43B; }
    .hljs-meta { color: #A1A1AA; }
    .hljs-deletion { color: #FF6B6B; }
    .hljs-addition { color: #51CF66; }
    .hljs-emphasis { font-style: italic; }
    .hljs-strong { font-weight: bold; }

    /* Typography & Content */
    .prose p {
      margin: 0 0 12px 0;
      line-height: 1.8;
      color: var(--text-secondary);
    }
    .prose h2 {
      font-size: 20px;
      margin: 20px 0 8px 0;
      color: var(--text);
    }
    .section { margin: 24px 0; }

    /* API Endpoints */
    .endpoint-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 18px;
      margin: 24px 0 8px 0;
    }
    .method-badge {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--accent);
      color: var(--bg);
    }
    .path {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: var(--text-secondary);
    }
  </style>
</head>
<body>
  <div id="upload-view">
    <div class="upload-card">
      <h1 class="upload-title">Build Docs from JSON</h1>
      <p class="upload-sub">Upload a JSON file containing pages and code snippets.</p>
      <div class="row">
        <input id="jsonFile" type="file" accept=".json,application/json">
        <button id="loadBtn" class="primary">Load</button>
      </div>
      <div id="error" class="error"></div>
    </div>
  </div>

  <div id="docs-view">
    <div class="layout">
      <aside>
        <div class="brand">Docs</div>
        <div id="sidebar"></div>
        <div id="sidebar-resizer" class="sidebar-resizer"></div>
      </aside>
      <main>
        <div id="content"></div>
      </main>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/python.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/bash.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/javascript.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/typescript.min.js"></script>
  <script>
    const state = { pages: [], currentIndex: 0 };
    const el = id => document.getElementById(id);
    const setError = msg => { const e = el('error'); e.textContent = msg || ''; };
    const createDownArrow = () => {
      const ns = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(ns, 'svg');
      svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      svg.setAttribute('viewBox', '0 0 24 24');
      svg.setAttribute('fill', 'currentColor');
      svg.setAttribute('class', 'arrow');
      const path = document.createElementNS(ns, 'path');
      path.setAttribute('d', 'M11.9999 13.1714L16.9497 8.22168L18.3639 9.63589L11.9999 15.9999L5.63599 9.63589L7.0502 8.22168L11.9999 13.1714Z');
      svg.appendChild(path);
      return svg;
    };
    const languageMeta = k => {
      const key = String(k || '').toLowerCase();
      if (key === 'python' || key === 'py') return { label: 'Python', hljs: 'python' };
      if (key === 'curl') return { label: 'cURL', hljs: 'bash' };
      if (key === 'bash' || key === 'sh' || key === 'shell') return { label: 'Bash', hljs: 'bash' };
      if (key === 'javascript' || key === 'js' || key === 'node') return { label: 'JavaScript', hljs: 'javascript' };
      if (key === 'typescript' || key === 'ts') return { label: 'TypeScript', hljs: 'typescript' };
      if (key === 'json') return { label: 'JSON', hljs: 'json' };
      return { label: k, hljs: key };
    };
    const toArray = v => Array.isArray(v) ? v : (v === undefined || v === null ? [] : [v]);
    const extractParagraphs = value => {
      const out = [];
      const add = t => { if (t && String(t).trim()) out.push(String(t).trim()); };
      if (typeof value === 'string') {
        value.split(/\n\s*\n/).forEach(add);
      } else if (Array.isArray(value)) {
        value.forEach(v => extractParagraphs(v).forEach(p => out.push(p)));
      } else if (value && typeof value === 'object') {
        const ps = value.paragraphs ?? value.body ?? value.description ?? value.content ?? value.text;
        extractParagraphs(ps).forEach(p => out.push(p));
        const sections = value.sections ?? value.blocks ?? value.items;
        toArray(sections).forEach(s => extractParagraphs(s).forEach(p => out.push(p)));
      } else if (value != null) {
        add(String(value));
      }
      return out;
    };
    const normalizeCodes = input => {
      const codes = [];
      if (!input) return codes;
      if (typeof input === 'string') {
        codes.push({ label: 'Text', hljs: 'plaintext', code: input });
        return codes;
      }
      if (Array.isArray(input)) {
        input.forEach(item => {
          if (!item) return;
          const lang = item.language ?? item.lang ?? item.type ?? item.name;
          const src = item.code ?? item.snippet ?? item.text ?? item.content ?? item.example;
          if (src !== undefined) {
            const meta = languageMeta(lang || 'text');
            codes.push({ label: meta.label, hljs: meta.hljs, code: typeof src === 'string' ? src : JSON.stringify(src, null, 2) });
          } else if (typeof item === 'string') {
            codes.push({ label: 'Text', hljs: 'plaintext', code: item });
          }
        });
        return codes;
      }
      if (typeof input === 'object') {
        const map = input.code_snippet ?? input.codeSnippet ?? input.snippets ?? input.examples ?? input;
        Object.entries(map).forEach(([lang, src]) => {
          let codeText = '';
          if (typeof src === 'string') codeText = src;
          else if (Array.isArray(src)) codeText = src.map(v => typeof v === 'string' ? v : JSON.stringify(v, null, 2)).join('\n');
          else if (src && typeof src === 'object') codeText = src.code ?? src.snippet ?? src.text ?? src.content ?? JSON.stringify(src, null, 2);
          else if (src != null) codeText = String(src);
          const meta = languageMeta(lang);
          codes.push({ label: meta.label, hljs: meta.hljs, code: codeText });
        });
        return codes;
      }
      return codes;
    };
    const normalizeSections = raw => {
      const sections = [];
      const arr = toArray(raw);
      arr.forEach(item => {
        if (!item) return;
        if (typeof item === 'string') {
          sections.push({ heading: undefined, paragraphs: extractParagraphs(item), codes: [] });
          return;
        }
        if (Array.isArray(item)) {
          sections.push({ heading: undefined, paragraphs: extractParagraphs(item), codes: [] });
          return;
        }
        if (typeof item === 'object') {
          const heading = item.heading ?? item.title ?? item.name;
          const paragraphs = extractParagraphs(item);
          const codes = normalizeCodes(item.code ?? item.code_snippet ?? item.codeSnippet ?? item.snippets ?? item.examples);
          sections.push({ heading, paragraphs, codes });
          if (Array.isArray(item.endpoints)) {
            item.endpoints.forEach(ep => {
              if (!ep) return;
              const method = (ep.method || '').toUpperCase();
              const path = ep.path ?? ep.url ?? ep.endpoint;
              const name = ep.name ?? ep.title;
              const epHeading = [method, path].filter(Boolean).join(' ');
              const fullHeading = name ? (epHeading ? epHeading + ' – ' + name : name) : epHeading || undefined;
              const epParagraphs = extractParagraphs(ep.description ?? ep.body ?? ep.overview ?? ep.docs ?? ep.text);
              const epCodes = normalizeCodes(ep.examples ?? ep.code ?? ep.code_snippet ?? ep.codeSnippet ?? ep.snippets);
              sections.push({ heading: fullHeading, paragraphs: epParagraphs, codes: epCodes, method, path });
            });
          }
        }
      });
      return sections;
    };
    const normalizeContentBlocks = (blocks, pageTitle) => {
      const sections = [];
      let current = null;
      const ensureCurrent = () => {
        if (!current) {
          current = { heading: pageTitle || undefined, paragraphs: [], codes: [] };
          sections.push(current);
        }
      };
      const flushParaBuffer = buffer => {
        const text = buffer.join('\n').trim();
        if (!text) return;
        const parts = text.split(/\n\s*\n/).map(s => s.trim()).filter(Boolean);
        parts.forEach(t => current.paragraphs.push(t));
      };
      if (!Array.isArray(blocks)) return sections;
      blocks.forEach(block => {
        if (!block) return;
        if (block.type === 'text' && typeof block.value === 'string') {
          const lines = block.value.split(/\r?\n/);
          let buffer = [];
          let foundHeading = false;
          lines.forEach(line => {
            const m = line.match(/^##\s*(.+)$/);
            if (m) {
              if (current && buffer.length) flushParaBuffer(buffer);
              buffer = [];
              foundHeading = true;
              current = { heading: m[1].trim(), paragraphs: [], codes: [] };
              sections.push(current);
              return;
            }
            if (!current) ensureCurrent();
            if (line.trim() === '') {
              flushParaBuffer(buffer);
              buffer = [];
            } else {
              buffer.push(line);
            }
          });
          if (!current) ensureCurrent();
          if (buffer.length) flushParaBuffer(buffer);
          if (!foundHeading && !pageTitle && !current.heading && current.paragraphs.length === 0) current.heading = undefined;
          return;
        }
        if (block.type === 'code_snippet' && block.languages && typeof block.languages === 'object') {
          if (!current) ensureCurrent();
          const codes = normalizeCodes(block.languages);
          codes.forEach(c => current.codes.push(c));
          return;
        }
      });
      return sections;
    };
    const normalizePage = (title, description, codeBlock, extra = {}) => {
      const codes = [];
      normalizeCodes(codeBlock).forEach(c => codes.push(c));
      const sections = normalizeSections(extra.sections ?? extra.blocks ?? extra.items ?? extra.endpoints);
      return { title: title || 'Untitled', description: description ?? '', codes, sections };
    };
    const normalizeInput = data => {
      const source = data && (data.pages ?? data);
      const pages = [];
      if (Array.isArray(source)) {
        const hasContentBlocks = source.some(p => p && Array.isArray(p.content));
        if (hasContentBlocks) {
          source.forEach(item => {
            if (!item) return;
            const title = item.title ?? item.name ?? item.key;
            const sections = normalizeContentBlocks(item.content || [], title);
            if (!sections.length) {
              pages.push({ title: title || 'Untitled', description: item.description ?? '', codes: [], sections: [] });
            } else {
              sections.forEach(sec => {
                pages.push({
                  title: sec.heading || title || 'Untitled',
                  description: sec.paragraphs,
                  codes: sec.codes,
                  sections: []
                });
              });
            }
          });
        } else {
          source.forEach(item => {
            const title = item && (item.title ?? item.name ?? item.key);
            const description = item && (item.description ?? item.overview ?? item.intro ?? item.content ?? item.text ?? '');
            const code = item && (item.code_snippet ?? item.codeSnippet ?? item.code ?? item.snippets ?? item.examples ?? {});
            pages.push(normalizePage(title, description, code, item));
          });
        }
      } else if (source && typeof source === 'object') {
        Object.entries(source).forEach(([key, value]) => {
          let description = '';
          let code = {};
          if (Array.isArray(value)) {
            description = value[0] ?? '';
            const second = value[1];
            if (second && typeof second === 'object') code = second.code_snippet ?? second.codeSnippet ?? second.code ?? second;
          } else if (value && typeof value === 'object') {
            description = value.description ?? value.overview ?? value.intro ?? value.content ?? value.text ?? '';
            code = value.code_snippet ?? value.codeSnippet ?? value.code ?? value.snippets ?? value.examples ?? {};
          } else if (value != null) {
            description = String(value);
          }
          pages.push(normalizePage(key, description, code, value && typeof value === 'object' ? value : {}));
        });
      }
      return pages;
    };
    const buildSidebar = () => {
      const sb = el('sidebar');
      sb.innerHTML = '';
      state.pages.forEach((p, i) => {
        const b = document.createElement('button');
        b.className = 'nav-item' + (i === state.currentIndex ? ' active' : '');
        b.textContent = p.title;
        b.addEventListener('click', () => activate(i));
        sb.appendChild(b);
      });
    };
    const renderPage = index => {
      const container = el('content');
      container.innerHTML = '';
      const page = state.pages[index];
      const h = document.createElement('h1');
      h.className = 'page-title';
      h.textContent = page.title;
      container.appendChild(h);
      if (page.description !== undefined && page.description !== null) {
        const d = document.createElement('div');
        d.className = 'description prose';
        const renderParagraphs = value => {
          if (typeof value === 'string') {
            const chunks = value.split(/\n\s*\n/).map(s => s.trim()).filter(Boolean);
            chunks.forEach(text => {
              const p = document.createElement('p');
              p.textContent = text;
              d.appendChild(p);
            });
            return;
          }
          if (Array.isArray(value)) {
            value.forEach(v => renderParagraphs(v));
            return;
          }
          if (value && typeof value === 'object') {
            const t = value.title ?? value.heading;
            const ps = value.paragraphs ?? value.description ?? value.content ?? value.text;
            if (t) {
              const h = document.createElement('h2');
              h.textContent = t;
              d.appendChild(h);
            }
            if (ps !== undefined) renderParagraphs(ps);
            const sections = value.sections ?? value.blocks;
            if (Array.isArray(sections)) sections.forEach(s => renderParagraphs(s));
            return;
          }
          const p = document.createElement('p');
          p.textContent = String(value);
          d.appendChild(p);
        };
        renderParagraphs(page.description);
        container.appendChild(d);
      }
      const renderCodeTabs = (host, codes) => {
        if (!codes || !codes.length) return;
        const group = document.createElement('div');
        group.className = 'code-group';
        const tabs = document.createElement('div');
        tabs.className = 'tabs';
        const blocks = document.createElement('div');
        codes.forEach((c, i) => {
          const cell = document.createElement('div');
          cell.className = 'code-cell' + (codes.length > 1 ? ' with-tabs' : '');
          cell.style.display = i === 0 ? 'block' : 'none';
          const pre = document.createElement('pre');
          const code = document.createElement('code');
          code.className = 'language-' + c.hljs;
          code.textContent = c.code;
          pre.appendChild(code);
          cell.appendChild(pre);
          blocks.appendChild(cell);
        });
        group.appendChild(blocks);
        if (codes.length > 1) {
          const select = document.createElement('button');
          select.className = 'tab-select';
          const labelSpan = document.createElement('span');
          labelSpan.textContent = codes[0].label;
          select.appendChild(labelSpan);
          const arrow = createDownArrow();
          select.appendChild(arrow);
          const menu = document.createElement('div');
          menu.className = 'tab-menu';
          codes.forEach((c, i) => {
            const item = document.createElement('button');
            item.className = 'tab';
            item.textContent = c.label;
            item.addEventListener('click', () => {
              labelSpan.textContent = c.label;
              menu.classList.remove('open');
              [...blocks.children].forEach((child, j) => child.style.display = j === i ? 'block' : 'none');
              const activeCode = blocks.children[i]?.querySelector('code');
              if (activeCode && !activeCode.classList.contains('hljs')) {
                hljs.highlightElement(activeCode);
              }
            });
            menu.appendChild(item);
          });
          select.addEventListener('click', e => {
            e.stopPropagation();
            menu.classList.toggle('open');
            const isOpen = menu.classList.contains('open');
            if (isOpen) select.classList.add('open'); else select.classList.remove('open');
          });
          document.addEventListener('click', e => {
            if (!tabs.contains(e.target)) menu.classList.remove('open');
          });
          tabs.appendChild(select);
          tabs.appendChild(menu);
          group.appendChild(tabs);
        }
        host.appendChild(group);
        blocks.querySelectorAll('code').forEach(e => hljs.highlightElement(e));
      };
      if (page.codes && page.codes.length) renderCodeTabs(container, page.codes);
      if (page.sections && page.sections.length) {
        page.sections.forEach(sec => {
          const s = document.createElement('section');
          s.className = 'section prose';
          if (sec.method || sec.path || sec.heading) {
            const h = document.createElement('div');
            h.className = 'endpoint-title';
            if (sec.method) {
              const m = document.createElement('span');
              m.className = 'method-badge';
              m.textContent = sec.method;
              h.appendChild(m);
            }
            const t = document.createElement('span');
            t.className = 'path';
            t.textContent = sec.path ? (sec.heading ? sec.path : sec.path) : (sec.heading || '');
            h.appendChild(t);
            if (!sec.path && sec.heading) {
              t.textContent = sec.heading;
            } else if (sec.path && sec.heading && sec.heading.includes('–')) {
              const extra = document.createElement('span');
              extra.textContent = ' ' + sec.heading.split('–').slice(1).join('–').trim();
              h.appendChild(extra);
            }
            s.appendChild(h);
          }
          toArray(sec.paragraphs).forEach(pText => {
            const p = document.createElement('p');
            p.textContent = pText;
            s.appendChild(p);
          });
          renderCodeTabs(s, sec.codes);
          s.querySelectorAll('code').forEach(e => hljs.highlightElement(e));
          container.appendChild(s);
        });
      }
    };
    const activate = i => {
      state.currentIndex = i;
      renderPage(i);
      const items = el('sidebar').querySelectorAll('.nav-item');
      items.forEach((n, idx) => {
        if (idx === i) n.classList.add('active'); else n.classList.remove('active');
      });
    };
    el('loadBtn').addEventListener('click', () => {
      const f = el('jsonFile').files[0];
      if (!f) { setError('Select a JSON file'); return; }
      const r = new FileReader();
      r.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          const pages = normalizeInput(data);
          if (!pages.length) { setError('No pages found in JSON'); return; }
          state.pages = pages;
          state.currentIndex = 0;
          el('upload-view').style.display = 'none';
          el('docs-view').style.display = 'block';
          buildSidebar();
          renderPage(0);
          setError('');
        } catch (err) {
          setError('Invalid JSON');
        }
      };
      r.onerror = () => setError('Failed to read file');
      r.readAsText(f);
    });

    const asideEl = document.querySelector('aside');
    const resizer = document.getElementById('sidebar-resizer');
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    const setSidebarWidth = w => {
      const min = 180;
      const max = 560;
      const width = Math.min(max, Math.max(min, w));
      document.documentElement.style.setProperty('--sidebar-width', width + 'px');
    };

    const onMouseMove = e => {
      if (!isResizing) return;
      const dx = e.clientX - startX;
      setSidebarWidth(startWidth + dx);
    };
    const onMouseUp = () => {
      if (!isResizing) return;
      isResizing = false;
      document.body.style.userSelect = '';
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };
    if (resizer && asideEl) {
      resizer.addEventListener('mousedown', e => {
        isResizing = true;
        startX = e.clientX;
        startWidth = asideEl.getBoundingClientRect().width;
        document.body.style.userSelect = 'none';
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
      resizer.addEventListener('mouseenter', () => asideEl.classList.add('accent-border'));
      resizer.addEventListener('mouseleave', () => {
        if (!isResizing) asideEl.classList.remove('accent-border');
      });
    }
  </script>
</body>
</html>


